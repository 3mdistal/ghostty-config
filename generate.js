#!/usr/bin/env node

/**
 * Ghostty Config Generator
 * 
 * Reads a JSON config file and generates Ghostty config output based on
 * the current macOS appearance (light/dark mode).
 * 
 * Usage: node generate.js [config-path] [output-path]
 * 
 * If no config path is provided, it defaults to config.json in the same directory.
 * If no output path is provided, output goes to stdout.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Get config path from args or use default
const configPath = process.argv[2] || path.join(__dirname, 'config.json');
const outputPath = process.argv[3] || null;

/**
 * Detect if macOS is in dark mode
 * @returns {boolean} true if dark mode, false if light mode
 */
function isDarkMode() {
  try {
    const result = execSync('defaults read -g AppleInterfaceStyle 2>/dev/null', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
    return result === 'Dark';
  } catch (e) {
    // If the command fails, it means light mode (the key doesn't exist)
    return false;
  }
}

/**
 * Convert a JSON config value to Ghostty config format
 * @param {string} key - The config key
 * @param {any} value - The config value
 * @returns {string[]} Array of config lines
 */
function formatConfigValue(key, value) {
  const lines = [];
  
  if (Array.isArray(value)) {
    // Handle array values (like palette or keybind)
    for (const item of value) {
      lines.push(`${key} = ${item}`);
    }
  } else if (typeof value === 'boolean') {
    lines.push(`${key} = ${value}`);
  } else if (typeof value === 'number') {
    lines.push(`${key} = ${value}`);
  } else if (typeof value === 'string') {
    lines.push(`${key} = ${value}`);
  }
  
  return lines;
}

/**
 * Generate Ghostty config from JSON config object
 * @param {object} config - The JSON config object
 * @param {boolean} darkMode - Whether dark mode is active
 * @returns {string} The generated Ghostty config
 */
function generateConfig(config, darkMode) {
  const lines = [];
  const modeKey = darkMode ? 'dark' : 'light';
  const modeConfig = config[modeKey] || {};
  
  // Add header comment
  lines.push(`# Generated by ghostty-config`);
  lines.push(`# Mode: ${modeKey}`);
  lines.push(`# Generated at: ${new Date().toISOString()}`);
  lines.push('');
  
  // Process shared config (everything except dark/light/$schema)
  const sharedKeys = Object.keys(config).filter(
    k => k !== 'dark' && k !== 'light' && k !== '$schema'
  );
  
  if (sharedKeys.length > 0) {
    lines.push('# Shared configuration');
    for (const key of sharedKeys) {
      lines.push(...formatConfigValue(key, config[key]));
    }
    lines.push('');
  }
  
  // Process mode-specific config
  const modeKeys = Object.keys(modeConfig);
  if (modeKeys.length > 0) {
    lines.push(`# ${modeKey.charAt(0).toUpperCase() + modeKey.slice(1)} mode configuration`);
    for (const key of modeKeys) {
      lines.push(...formatConfigValue(key, modeConfig[key]));
    }
    lines.push('');
  }
  
  return lines.join('\n');
}

// Main execution
try {
  // Read and parse config
  const configContent = fs.readFileSync(configPath, 'utf-8');
  const config = JSON.parse(configContent);
  
  // Detect mode and generate config
  const darkMode = isDarkMode();
  const output = generateConfig(config, darkMode);
  
  if (outputPath) {
    // Write to file
    fs.writeFileSync(outputPath, output, 'utf-8');
    console.error(`Config written to ${outputPath} (${darkMode ? 'dark' : 'light'} mode)`);
  } else {
    // Output to stdout
    console.log(output);
  }
  
} catch (error) {
  console.error(`# Error generating config: ${error.message}`);
  process.exit(1);
}
